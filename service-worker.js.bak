try{self["workbox:core:7.0.0"]&&_()}catch{}const C=(t,...e)=>{let n=t;return e.length>0&&(n+=` :: ${JSON.stringify(e)}`),n},M=C;class y extends Error{constructor(e,n){const r=M(e,n);super(r),this.name=e,this.details=n}}try{self["workbox:routing:7.0.0"]&&_()}catch{}const v="GET",g=t=>t&&typeof t=="object"?t:{handle:t};class p{constructor(e,n,r=v){this.handler=g(n),this.match=e,this.method=r}setCatchHandler(e){this.catchHandler=g(e)}}class b extends p{constructor(e,n,r){const o=({url:a})=>{const i=e.exec(a.href);if(i&&!(a.origin!==location.origin&&i.index!==0))return i.slice(1)};super(o,n,r)}}class L{constructor(){this._routes=new Map,this._defaultHandlerMap=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",e=>{const{request:n}=e,r=this.handleRequest({request:n,event:e});r&&e.respondWith(r)})}addCacheListener(){self.addEventListener("message",e=>{if(e.data&&e.data.type==="CACHE_URLS"){const{payload:n}=e.data,r=Promise.all(n.urlsToCache.map(o=>{typeof o=="string"&&(o=[o]);const a=new Request(...o);return this.handleRequest({request:a,event:e})}));e.waitUntil(r),e.ports&&e.ports[0]&&r.then(()=>e.ports[0].postMessage(!0))}})}handleRequest({request:e,event:n}){const r=new URL(e.url,location.href);if(!r.protocol.startsWith("http"))return;const o=r.origin===location.origin,{params:a,route:i}=this.findMatchingRoute({event:n,request:e,sameOrigin:o,url:r});let s=i&&i.handler;const u=e.method;if(!s&&this._defaultHandlerMap.has(u)&&(s=this._defaultHandlerMap.get(u)),!s)return;let h;try{h=s.handle({url:r,request:e,event:n,params:a})}catch(l){h=Promise.reject(l)}const m=i&&i.catchHandler;return h instanceof Promise&&(this._catchHandler||m)&&(h=h.catch(async l=>{if(m)try{return await m.handle({url:r,request:e,event:n,params:a})}catch(x){x instanceof Error&&(l=x)}if(this._catchHandler)return this._catchHandler.handle({url:r,request:e,event:n});throw l})),h}findMatchingRoute({url:e,sameOrigin:n,request:r,event:o}){const a=this._routes.get(r.method)||[];for(const i of a){let s;const u=i.match({url:e,sameOrigin:n,request:r,event:o});if(u)return s=u,(Array.isArray(s)&&s.length===0||u.constructor===Object&&Object.keys(u).length===0||typeof u=="boolean")&&(s=void 0),{route:i,params:s}}return{}}setDefaultHandler(e,n=v){this._defaultHandlerMap.set(n,g(e))}setCatchHandler(e){this._catchHandler=g(e)}registerRoute(e){this._routes.has(e.method)||this._routes.set(e.method,[]),this._routes.get(e.method).push(e)}unregisterRoute(e){if(!this._routes.has(e.method))throw new y("unregister-route-but-not-found-with-method",{method:e.method});const n=this._routes.get(e.method).indexOf(e);if(n>-1)this._routes.get(e.method).splice(n,1);else throw new y("unregister-route-route-not-registered")}}let d;const S=()=>(d||(d=new L,d.addFetchListener(),d.addCacheListener()),d);function E(t,e,n){let r;if(typeof t=="string"){const a=new URL(t,location.href),i=({url:s})=>s.href===a.href;r=new p(i,e,n)}else if(t instanceof RegExp)r=new b(t,e,n);else if(typeof t=="function")r=new p(t,e,n);else if(t instanceof p)r=t;else throw new y("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});return S().registerRoute(r),r}var c=[];for(var w=0;w<256;++w)c.push((w+256).toString(16).slice(1));function k(t,e=0){return(c[t[e+0]]+c[t[e+1]]+c[t[e+2]]+c[t[e+3]]+"-"+c[t[e+4]]+c[t[e+5]]+"-"+c[t[e+6]]+c[t[e+7]]+"-"+c[t[e+8]]+c[t[e+9]]+"-"+c[t[e+10]]+c[t[e+11]]+c[t[e+12]]+c[t[e+13]]+c[t[e+14]]+c[t[e+15]]).toLowerCase()}var f,A=new Uint8Array(16);function D(){if(!f&&(f=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!f))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return f(A)}var O=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto);const U={randomUUID:O};function V(t,e,n){if(U.randomUUID&&!e&&!t)return U.randomUUID();t=t||{};var r=t.random||(t.rng||D)();if(r[6]=r[6]&15|64,r[8]=r[8]&63|128,e){n=n||0;for(var o=0;o<16;++o)e[n+o]=r[o];return e}return k(r)}const H="pseudoserver-data",R="/pseudoserver/";self.addEventListener("install",()=>{self.skipWaiting()});self.addEventListener("activate",t=>{t.waitUntil(self.clients.claim())});E("/pseudoserver/",async()=>{const e=await(await caches.open(H)).match(R,{ignoreMethod:!0,ignoreSearch:!0,ignoreVary:!0});return e===void 0?new Response("[]"):e},"GET");E("/pseudoserver/",async({request:t})=>{const e=await caches.open(H),n=await t.formData(),r={};for(const[i,s]of n.entries())if(console.log(i,typeof s,s),typeof s=="string")r[i]=s;else{const u=V();e.put(u,new Response(s)),r[i]=`/pseudoserver/${u}/`}const o=await e.match(R,{ignoreMethod:!0,ignoreSearch:!0,ignoreVary:!0});let a;return o===void 0?a=[r]:(a=await o.json(),a.push(r)),console.log(a),e.put(R,new Response(JSON.stringify(a))),new Response(JSON.stringify(r))},"POST");E(/\/pseudoserver\/(.*)\//,async({params:[t]})=>await(await caches.open(H)).match(t,{ignoreMethod:!0,ignoreSearch:!0,ignoreVary:!0}),"GET");
